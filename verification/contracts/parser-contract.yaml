# Contract Tests: Comment Parser

component: "Comment Parser"
interface: "ParseComments"
description: "Validates input/output contract for parsing markdown with CriticMarkup comments"

input_schema:
  content:
    type: string
    required: true
    constraints:
      - valid_utf8
      - max_size: 100MB

  syntax_flavor:
    type: enum
    values: [criticmarkup, standard]
    required: false
    default: criticmarkup

output_schema:
  success:
    comments:
      type: array<Comment>
      items:
        id: string
        author: string
        text: string
        line: integer
        timestamp: iso8601
        position: Position

    ast:
      type: DocumentAST
      fields:
        nodes: array<ASTNode>
        errors: array<ParseError>

    parse_warnings: array<Warning>

  error:
    code: enum[INVALID_SYNTAX, ENCODING_ERROR]
    message: string
    position: Position

# Happy Path Scenarios
valid_inputs:
  - name: "Single inline comment"
    input:
      content: |
        # Document Title
        Some text {>>[@alice:c1:5:2024-01-15T10:30:00Z] This is a comment <<} more text.
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            author: "alice"
            id: "c1"
            line: 5
            text: "This is a comment"
            timestamp: "2024-01-15T10:30:00Z"
      ast:
        node_count: ">= 1"
        has_comment_nodes: true

  - name: "Multiple comments in document"
    input:
      content: |
        Line 1
        Line 2 {>>[@bob:c1:2:2024-01-01T00:00:00Z] First comment <<}
        Line 3
        Line 4 {>>[@alice:c2:4:2024-01-02T00:00:00Z] Second comment <<}
    expect:
      success: true
      comments:
        - count: 2
        - comment_0:
            author: "bob"
            id: "c1"
        - comment_1:
            author: "alice"
            id: "c2"
      preserves_order: true

  - name: "Comment with special characters"
    input:
      content: |
        Text {>>[@user:id:1:2024-01-01T00:00:00Z] Comment with `code` and **bold** <<}
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            text: "Comment with `code` and **bold**"
      text_preserved_exactly: true

  - name: "Multi-line comment"
    input:
      content: |
        Text {>>[@user:id:1:2024-01-01T00:00:00Z]
        Line 1 of comment
        Line 2 of comment
        Line 3 of comment
        <<} more text
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            text_contains: ["Line 1", "Line 2", "Line 3"]
      line_breaks_preserved: true

  - name: "Comment with nested markup"
    input:
      content: |
        {>>[@user:id:1:2024-01-01T00:00:00Z] Text with {literal braces} inside <<}
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            text: "Text with {literal braces} inside"

  - name: "Empty document"
    input:
      content: ""
    expect:
      success: true
      comments:
        - count: 0
      ast:
        nodes: []
      warnings: []

  - name: "Document without comments"
    input:
      content: |
        # Regular Markdown
        Just normal text with no comments.
        - List item
        - Another item
    expect:
      success: true
      comments:
        - count: 0
      ast:
        node_count: ">= 3"
      warnings: []

# Validation Scenarios
invalid_inputs:
  - name: "Malformed comment - missing closing delimiter"
    input:
      content: "Text {>>[@user:id:1:2024-01-01T00:00:00Z] Unclosed comment"
    expect:
      success: true  # Best effort parsing
      comments:
        - count: 0
      warnings:
        - count: 1
        - warning_0:
            type: "UNCLOSED_COMMENT"
            position_line: 1

  - name: "Malformed comment - missing metadata"
    input:
      content: "Text {>>[@user] Missing timestamp <<}"
    expect:
      success: true
      warnings:
        - count: 1
        - warning_0:
            type: "INCOMPLETE_METADATA"
      comments:
        - count: 1
        - comment_0:
            author: "user"
            has_default_values: true

  - name: "Invalid timestamp format"
    input:
      content: "{>>[@user:id:1:invalid-date] Comment <<}"
    expect:
      success: true
      warnings:
        - count: 1
        - warning_0:
            type: "INVALID_TIMESTAMP"
      comments:
        - comment_0:
            timestamp_is_default: true

  - name: "Negative line number"
    input:
      content: "{>>[@user:id:-5:2024-01-01T00:00:00Z] Comment <<}"
    expect:
      success: true
      warnings:
        - count: 1
      comments:
        - comment_0:
            line: ">= 1"  # Should default to positive

  - name: "Extremely long comment text"
    input:
      content: "{>>[@user:id:1:2024-01-01T00:00:00Z] ${'x'.repeat(100000)} <<}"
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            text_length: 100000

  - name: "Invalid UTF-8 encoding"
    input:
      content: "\xFF\xFE Invalid UTF-8"
    expect:
      error: true
      error_code: "ENCODING_ERROR"

# Boundary Conditions
boundary_cases:
  - name: "Comment at document start"
    input:
      content: "{>>[@user:id:1:2024-01-01T00:00:00Z] Comment <<} Rest of doc"
    expect:
      success: true
      comments:
        - comment_0:
            position:
              start_offset: 0

  - name: "Comment at document end"
    input:
      content: "Doc content {>>[@user:id:1:2024-01-01T00:00:00Z] Comment <<}"
    expect:
      success: true
      comments:
        - comment_0:
            position:
              end_offset: "document_length"

  - name: "Adjacent comments"
    input:
      content: "{>>[@a:1:1:2024-01-01T00:00:00Z] First <<}{>>[@b:2:1:2024-01-01T00:00:00Z] Second <<}"
    expect:
      success: true
      comments:
        - count: 2
      comment_positions_distinct: true

  - name: "Comment with only whitespace text"
    input:
      content: "{>>[@user:id:1:2024-01-01T00:00:00Z]    <<}"
    expect:
      success: true
      comments:
        - count: 1
        - comment_0:
            text: "   "
      whitespace_preserved: true

  - name: "Comment with unicode emoji"
    input:
      content: "{>>[@user:id:1:2024-01-01T00:00:00Z] Great work! üéâüëç <<}"
    expect:
      success: true
      comments:
        - comment_0:
            text_contains: ["üéâ", "üëç"]

  - name: "Maximum realistic document size"
    input:
      content_size: 10MB
      comment_count: 10000
    expect:
      success: true
      parse_time: "< 5 seconds"
      memory_usage: "< 100MB"

# Error Recovery
error_recovery:
  - name: "Recover from partial malformation"
    input:
      content: |
        {>>[@user:id:1:2024-01-01T00:00:00Z] Good comment <<}
        {>>[@user:id:2 BAD COMMENT
        {>>[@user:id:3:2024-01-01T00:00:00Z] Another good comment <<}
    expect:
      success: true
      comments:
        - count: 2  # Good comments extracted
      warnings:
        - count: 1

  - name: "Continue parsing after error"
    input:
      content: |
        Line 1
        {>>MALFORMED<<}
        Line 3 {>>[@user:id:3:2024-01-01T00:00:00Z] Valid <<}
    expect:
      success: true
      comments:
        - count: 1
      warnings:
        - count: 1

# Round-trip Verification
round_trip:
  - name: "Parse and serialize identity"
    input:
      content: |
        Text {>>[@alice:c1:1:2024-01-01T00:00:00Z] Comment <<} more
    operation:
      - parse: true
      - serialize: true
      - parse_again: true
    expect:
      content_identical: true
      comment_count_unchanged: true
      no_data_loss: true

  - name: "Multiple round-trips preserve data"
    iterations: 10
    operation: "parse -> serialize -> parse"
    expect:
      stable_after: 1  # First round-trip
      no_accumulation: true

# Performance Contracts
performance:
  - name: "Small document parse time"
    input:
      size: "< 10KB"
    expect:
      parse_time: "< 10ms"

  - name: "Medium document parse time"
    input:
      size: "< 1MB"
    expect:
      parse_time: "< 500ms"

  - name: "Large document parse time"
    input:
      size: "< 10MB"
    expect:
      parse_time: "< 5s"

  - name: "Linear scaling with document size"
    inputs:
      - {size: 100KB, expected_time: "~50ms"}
      - {size: 200KB, expected_time: "~100ms"}
      - {size: 400KB, expected_time: "~200ms"}
    expect:
      scaling: "O(n)"

  - name: "Memory efficiency"
    input:
      size: 1MB
    expect:
      memory_overhead: "< 10x input size"
      no_memory_leaks: true

# Idempotency
idempotency:
  assertion: "Parsing same content multiple times produces identical results"
  verification:
    - "Parse content N times"
    - "Compare all results"
    - "Assert all equal"

# State Invariants
invariants:
  - "Output comment count never negative"
  - "All comment IDs are non-empty strings"
  - "All timestamps are valid ISO8601 or default"
  - "All line numbers are positive integers"
  - "All positions within document bounds"
  - "Comment order matches document order"
  - "AST structure is valid tree"
  - "No duplicate comment IDs within document"
