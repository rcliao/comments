# Contract Tests: Document Manager

component: "Document Manager"
interface: "DocumentOperations"
description: "Validates file I/O, persistence, and document lifecycle contracts"

# OpenDocument Contract
open_document:
  operation: "OpenDocument"

  input_schema:
    filepath:
      type: string
      required: true
      constraints:
        - valid_path
        - absolute_or_relative

    encoding:
      type: string
      required: false
      default: "utf-8"
      allowed: ["utf-8", "utf-16", "ascii", "latin-1"]

  output_schema:
    success:
      document_id: uuid
      content: string
      comments: array<Comment>
      statistics:
        total_comments: integer
        active_threads: integer
        line_count: integer
        char_count: integer

    error:
      code: enum[FILE_NOT_FOUND, PERMISSION_DENIED, PARSE_ERROR]
      message: string
      details: object

  scenarios:
    - name: "Open existing valid file"
      setup:
        - create_file: "/tmp/test.md"
        - content: "# Test\nContent"
      input:
        filepath: "/tmp/test.md"
      expect:
        success: true
        document_id: "non_null"
        content: "# Test\nContent"
        statistics:
          line_count: 2
          char_count: 15

    - name: "Open file with UTF-8 encoding"
      setup:
        - create_file_with_encoding: "utf-8"
        - content: "Hello 世界 🌍"
      input:
        filepath: "/tmp/utf8.md"
        encoding: "utf-8"
      expect:
        success: true
        content_includes: ["世界", "🌍"]
        no_encoding_errors: true

    - name: "Open non-existent file"
      input:
        filepath: "/non/existent/path.md"
      expect:
        error: true
        error_code: "FILE_NOT_FOUND"
        message_contains: "does not exist"

    - name: "Open file without permissions"
      setup:
        - create_file: "/tmp/noperm.md"
        - chmod: "000"
      input:
        filepath: "/tmp/noperm.md"
      expect:
        error: true
        error_code: "PERMISSION_DENIED"

    - name: "Open file already open"
      setup:
        - open_once: "/tmp/test.md"
      input:
        filepath: "/tmp/test.md"
      expect:
        returns_existing_document_id: true
        or_creates_new_instance: true

  idempotent: true
  async: true

# SaveDocument Contract
save_document:
  operation: "SaveDocument"

  input_schema:
    document_id:
      type: uuid
      required: true

    create_backup:
      type: boolean
      required: false
      default: true

  output_schema:
    success:
      saved_at: timestamp
      bytes_written: integer
      backup_path: string?

    error:
      code: enum[DOCUMENT_NOT_FOUND, WRITE_ERROR, DISK_FULL]
      message: string

  scenarios:
    - name: "Save modified document"
      setup:
        - open_document: "test.md"
        - modify_content: "add text"
        - document_dirty: true
      input:
        document_id: "{opened_doc_id}"
        create_backup: true
      expect:
        success: true
        bytes_written: "> 0"
        backup_path: "not_null"
        file_exists: "test.md"
        backup_exists: true

    - name: "Save unmodified document"
      setup:
        - open_document: "test.md"
        - no_modifications: true
      input:
        document_id: "{doc_id}"
      expect:
        success: true
        operation_skipped_or_executed: true

    - name: "Save to disk full"
      setup:
        - simulate_disk_full: true
      input:
        document_id: "{doc_id}"
      expect:
        error: true
        error_code: "DISK_FULL"
        original_file_intact: true

    - name: "Save with backup disabled"
      input:
        document_id: "{doc_id}"
        create_backup: false
      expect:
        success: true
        backup_path: null

    - name: "Save non-existent document"
      input:
        document_id: "00000000-0000-0000-0000-000000000000"
      expect:
        error: true
        error_code: "DOCUMENT_NOT_FOUND"

    - name: "Atomic save operation"
      setup:
        - open_document: "test.md"
        - modify_content: "new content"
      input:
        document_id: "{doc_id}"
      verification:
        - temp_file_used: true
        - rename_operation_atomic: true
        - no_partial_writes: true
      expect:
        success: true
        file_integrity: verified

  idempotent: false
  async: true
  atomicity: required

# Change Detection
change_detection:
  operation: "DetectChanges"

  scenarios:
    - name: "Detect content modification"
      setup:
        - open_document: "test.md"
        - initial_checksum: "{hash}"
      when:
        - modify_content: "add line"
      expect:
        dirty_flag: true
        checksum_changed: true
        change_event_fired: true

    - name: "Detect comment addition"
      setup:
        - open_document: "test.md"
      when:
        - add_comment: "new comment"
      expect:
        dirty_flag: true
        modified_indicator: visible
        unsaved_changes: true

    - name: "Detect external file change"
      setup:
        - open_document: "test.md"
        - file_checksum: "{initial}"
      when:
        - external_process_modifies_file: true
      expect:
        external_change_detected: true
        reload_prompt_shown: true
        user_choice_options: ["reload", "keep_current", "merge"]

# Encoding Detection
encoding_tests:
  - name: "Auto-detect UTF-8"
    input:
      file_content: "UTF-8 content 🎉"
      bom: none
    expect:
      detected_encoding: "utf-8"

  - name: "Auto-detect UTF-16 with BOM"
    input:
      file_content: "UTF-16 content"
      bom: "utf-16-le"
    expect:
      detected_encoding: "utf-16"

  - name: "Auto-detect ASCII"
    input:
      file_content: "Plain ASCII"
    expect:
      detected_encoding: "ascii"
      compatible_with: "utf-8"

  - name: "Handle mixed encodings gracefully"
    input:
      file_has_mixed_encoding: true
    expect:
      best_effort_decode: true
      warnings_generated: true

# File Locking
file_locking:
  - name: "Acquire lock on open"
    when:
      - open_document: "test.md"
    expect:
      lock_acquired: true
      lock_type: "advisory"

  - name: "Prevent concurrent writes"
    when:
      - process_a_opens: "test.md"
      - process_b_tries_open: "test.md"
    expect:
      process_b_notified: true
      read_only_mode_or_wait: true

  - name: "Release lock on close"
    when:
      - open_document: "test.md"
      - close_document: true
    expect:
      lock_released: true

# Backup Management
backup_tests:
  - name: "Create backup on first save"
    when:
      - save_document: true
    expect:
      backup_created: true
      backup_naming: "*.bak or *.md~"

  - name: "Rotate backups"
    setup:
      - max_backups: 5
    when:
      - save_multiple_times: 10
    expect:
      backup_count: 5
      oldest_removed: true

  - name: "Backup content matches pre-save"
    when:
      - save_document: true
    expect:
      backup_content: equals_previous_version

  - name: "Restore from backup"
    when:
      - restore_backup: "test.md.bak"
    expect:
      content_restored: true
      checksum_matches_backup: true

# Performance Contracts
performance:
  - name: "Open small file quickly"
    input:
      file_size: "< 100KB"
    expect:
      open_time: "< 100ms"

  - name: "Open large file reasonably"
    input:
      file_size: "< 10MB"
    expect:
      open_time: "< 2s"

  - name: "Save is fast"
    input:
      document_size: "1MB"
    expect:
      save_time: "< 500ms"

  - name: "Checksum calculation efficient"
    input:
      document_size: "5MB"
    expect:
      checksum_time: "< 200ms"

# Data Integrity
integrity_tests:
  - name: "Content matches file after open"
    verification:
      - read_file_directly: true
      - compare_with_document_content: true
    expect:
      exact_match: true

  - name: "Content matches file after save"
    verification:
      - save_document: true
      - read_file_directly: true
      - compare_with_document_content: true
    expect:
      exact_match: true

  - name: "No data corruption on crash"
    simulation:
      - modify_document: true
      - begin_save: true
      - crash_during_save: true
    expect:
      original_file_intact: true
      or_temp_file_complete: true
      no_partial_writes: true

  - name: "Checksum detects all changes"
    verification:
      - compute_initial_checksum: true
      - modify_single_byte: true
      - compute_new_checksum: true
    expect:
      checksums_differ: true

# State Transitions
state_machine:
  states: [unloaded, loading, loaded, modified, saving, saved, error]

  transitions:
    - from: unloaded
      to: loading
      trigger: "open_command"

    - from: loading
      to: loaded
      trigger: "parse_success"

    - from: loading
      to: error
      trigger: "open_failed"

    - from: loaded
      to: modified
      trigger: "content_change"

    - from: modified
      to: saving
      trigger: "save_command"

    - from: saving
      to: saved
      trigger: "save_success"

    - from: saving
      to: error
      trigger: "save_failed"

# Invariants
invariants:
  - "Document ID unique across session"
  - "Filepath always absolute after resolution"
  - "Content in memory matches file when not modified"
  - "Checksum always reflects current content"
  - "Dirty flag true iff content differs from file"
  - "Backup exists after successful save with backup=true"
  - "Lock released on document close"
  - "No data loss on error conditions"
