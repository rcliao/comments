# Contract Tests: Position Tracker

component: "Position Tracker"
interface: "UpdatePositions"
description: "Validates position tracking and comment anchor management through edits"

input_schema:
  document_id:
    type: uuid
    required: true

  edit_operation:
    type: EditOperation
    required: true
    fields:
      type: enum[insert, delete, replace]
      position: Position
      old_text: string?
      new_text: string?
      delta: integer  # Net character change

output_schema:
  success:
    updated_comments:
      type: array
      items:
        comment_id: string
        old_position: Position
        new_position: Position
        status: enum[moved, unchanged, conflicted]

    conflicts:
      type: array
      items:
        comment_id: string
        reason: string
        resolution: enum[move, delete, split]

  error:
    code: enum[INVALID_EDIT, DOCUMENT_NOT_FOUND]
    message: string

# Core Position Update Scenarios
position_updates:
  - name: "Insert before comment - simple shift"
    input:
      edit:
        type: insert
        position: 100
        new_text: "inserted text"
        delta: 13
      comments:
        - {id: "c1", start: 50, end: 60}   # Before edit
        - {id: "c2", start: 200, end: 220} # After edit
    expect:
      success: true
      updated_comments:
        - {id: "c1", status: "unchanged", new_start: 50, new_end: 60}
        - {id: "c2", status: "moved", new_start: 213, new_end: 233}
      conflicts: []

  - name: "Delete before comment - shift back"
    input:
      edit:
        type: delete
        start: 100
        end: 150
        delta: -50
      comments:
        - {id: "c1", start: 200, end: 220}
    expect:
      updated_comments:
        - {id: "c1", status: "moved", new_start: 150, new_end: 170}

  - name: "Insert after comment - no change"
    input:
      edit:
        type: insert
        position: 500
        delta: 20
      comments:
        - {id: "c1", start: 100, end: 120}
    expect:
      updated_comments:
        - {id: "c1", status: "unchanged", new_start: 100, new_end: 120}

  - name: "Replace at comment position"
    input:
      edit:
        type: replace
        start: 100
        end: 120
        old_text: "old function name"
        new_text: "new_name"
        delta: -9
      comments:
        - {id: "c1", start: 100, end: 120}
    expect:
      updated_comments:
        - id: "c1"
          status: "moved"
          new_start: 100
          new_end: 111  # 120 - 9
      warnings:
        - anchor_text_changed: true

  - name: "Multiple comments shifted by single edit"
    input:
      edit:
        type: insert
        position: 500
        delta: 100
      comments:
        - {id: "c1", start: 100, end: 110}
        - {id: "c2", start: 600, end: 610}
        - {id: "c3", start: 700, end: 710}
        - {id: "c4", start: 400, end: 410}
    expect:
      updated_comments:
        - {id: "c1", status: "unchanged"}
        - {id: "c4", status: "unchanged"}
        - {id: "c2", status: "moved", new_start: 700}
        - {id: "c3", status: "moved", new_start: 800}
      batch_update: true

# Conflict Scenarios
conflicts:
  - name: "Delete overlapping comment start"
    input:
      edit:
        type: delete
        start: 90
        end: 110
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      conflicts:
        - comment_id: "c1"
          reason: "start_position_deleted"
          resolution_options: ["move_to_90", "delete", "move_to_110"]

  - name: "Delete overlapping comment end"
    input:
      edit:
        type: delete
        start: 140
        end: 160
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      conflicts:
        - comment_id: "c1"
          reason: "end_position_deleted"
          resolution_options: ["truncate_to_140", "delete"]

  - name: "Delete entire comment"
    input:
      edit:
        type: delete
        start: 90
        end: 160
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      conflicts:
        - comment_id: "c1"
          reason: "fully_contained_in_deletion"
          resolution_options: ["delete", "move_to_boundary"]

  - name: "Replace containing comment"
    input:
      edit:
        type: replace
        start: 90
        end: 160
        new_text: "x"
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      conflicts:
        - comment_id: "c1"
          reason: "position_replaced"

  - name: "Partial overlap - comment extends beyond deletion"
    input:
      edit:
        type: delete
        start: 120
        end: 140
      comments:
        - {id: "c1", start: 100, end: 200}
    expect:
      updated_comments:
        - id: "c1"
          status: "moved"
          new_start: 100
          new_end: 180  # 200 - 20 deleted chars
      warnings:
        - anchor_partially_modified: true

# Boundary Conditions
boundaries:
  - name: "Edit at document start"
    input:
      edit:
        type: insert
        position: 0
        delta: 10
      comments:
        - {id: "c1", start: 0, end: 5}
        - {id: "c2", start: 20, end: 30}
    expect:
      updated_comments:
        - {id: "c1", status: "moved", new_start: 10, new_end: 15}
        - {id: "c2", status: "moved", new_start: 30, new_end: 40}

  - name: "Edit at document end"
    input:
      document_length: 1000
      edit:
        type: insert
        position: 1000
        delta: 50
      comments:
        - {id: "c1", start: 990, end: 1000}
    expect:
      updated_comments:
        - {id: "c1", status: "unchanged", new_end: 1000}

  - name: "Zero-length edit (cursor movement)"
    input:
      edit:
        type: insert
        position: 500
        delta: 0
      comments:
        - {id: "c1", start: 500, end: 510}
    expect:
      updated_comments:
        - {id: "c1", status: "unchanged"}
      no_position_changes: true

  - name: "Edit at exact comment boundary - start"
    input:
      edit:
        type: insert
        position: 100  # Exactly at comment start
        delta: 5
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      updated_comments:
        - id: "c1"
          status: "moved"
          new_start: 105  # Shifted forward
          new_end: 155

  - name: "Edit at exact comment boundary - end"
    input:
      edit:
        type: insert
        position: 150  # Exactly at comment end
        delta: 5
      comments:
        - {id: "c1", start: 100, end: 150}
    expect:
      updated_comments:
        - id: "c1"
          status: "unchanged"  # Insertion after end
          new_end: 150

  - name: "Comment at position zero"
    input:
      edit:
        type: insert
        position: 0
        delta: 10
      comments:
        - {id: "c1", start: 0, end: 0}  # Zero-width marker
    expect:
      updated_comments:
        - {id: "c1", new_start: 10, new_end: 10}

# Multi-byte Character Handling
unicode_handling:
  - name: "Insert multi-byte character"
    input:
      edit:
        type: insert
        position: 100
        new_text: "üéâ"  # 4-byte emoji
        delta: 4
      comments:
        - {id: "c1", start: 200, end: 210}
    expect:
      updated_comments:
        - {id: "c1", new_start: 204, new_end: 214}
      byte_offset_correct: true

  - name: "Delete containing multi-byte chars"
    input:
      edit:
        type: delete
        start: 100
        end: 120  # Contains emoji at 110
        delta: -20
      comments:
        - {id: "c1", start: 200, end: 210}
    expect:
      updated_comments:
        - {id: "c1", new_start: 180, new_end: 190}
      no_character_splitting: true

  - name: "Position in multi-byte text"
    input:
      document_content: "Hello ‰∏ñÁïå üåç"
      edit:
        type: insert
        position: 9  # After "‰∏ñÁïå"
        delta: 3
      comments:
        - {id: "c1", start: 12, end: 16}  # At emoji
    expect:
      updated_comments:
        - {id: "c1", new_start: 15, new_end: 19}
      character_boundaries_respected: true

# Line Number Updates
line_tracking:
  - name: "Insert new lines"
    input:
      edit:
        type: insert
        position: 500
        new_text: "line1\nline2\nline3\n"
        delta: 18
        lines_added: 3
      comments:
        - {id: "c1", line: 10, start: 400}
        - {id: "c2", line: 20, start: 600}
    expect:
      updated_comments:
        - {id: "c1", line: 10}  # Unchanged
        - {id: "c2", line: 23, start: 618}  # +3 lines

  - name: "Delete lines"
    input:
      edit:
        type: delete
        start: 500
        end: 700
        lines_deleted: 5
      comments:
        - {id: "c1", line: 10}  # Before deletion
        - {id: "c2", line: 30}  # After deletion
    expect:
      updated_comments:
        - {id: "c1", line: 10}
        - {id: "c2", line: 25}  # -5 lines

  - name: "Replace with different line count"
    input:
      edit:
        type: replace
        lines_removed: 3
        lines_added: 7
        net_line_change: +4
      comments:
        - {id: "c1", line: 50}
    expect:
      updated_comments:
        - {id: "c1", line: 54}

# Performance Tests
performance:
  - name: "Update 100 comments efficiently"
    input:
      edit: {type: insert, position: 500, delta: 10}
      comment_count: 100
    expect:
      update_time: "< 10ms"
      algorithm: "O(log n) binary search + O(k) updates"

  - name: "Update 1000 comments"
    input:
      comment_count: 1000
    expect:
      update_time: "< 100ms"

  - name: "Large edit delta"
    input:
      edit: {delta: 100000}
      comment_count: 500
    expect:
      update_time: "< 50ms"
      no_performance_degradation: true

  - name: "Batch multiple edits"
    input:
      edits: 10
      comments: 100
    expect:
      batch_processing: true
      single_position_map_update: true
      total_time: "< 50ms"

# Concurrency
concurrency:
  - name: "Sequential edits maintain consistency"
    input:
      edit_sequence:
        - {type: insert, position: 100, delta: 10}
        - {type: delete, position: 200, delta: -5}
        - {type: insert, position: 150, delta: 3}
      comments:
        - {id: "c1", start: 50}
        - {id: "c2", start: 180}
        - {id: "c3", start: 250}
    expect:
      final_positions_correct: true
      no_position_drift: true
      order_matters: true

  - name: "Rapid edits don't cause race"
    input:
      rapid_edits: 20
      time_span: "1 second"
    expect:
      all_updates_applied: true
      position_map_consistent: true
      no_lost_updates: true

# Undo/Redo Support
undo_redo:
  - name: "Undo edit reverses positions"
    input:
      original_position: 100
      edit: {type: insert, position: 50, delta: 10}
      new_position: 110
      undo: true
    expect:
      restored_position: 100
      exact_reversal: true

  - name: "Redo reapplies position change"
    input:
      sequence: [edit, undo, redo]
    expect:
      position_after_redo: equals_position_after_edit

# State Validation
validation:
  - name: "All positions within bounds"
    after_each_update:
      verify:
        - all_start_positions: ">= 0"
        - all_end_positions: "<= document_length"
        - all_starts_before_ends: true

  - name: "Position map consistency"
    after_each_update:
      verify:
        - map_size: equals_comment_count
        - all_ids_present: true
        - no_duplicate_positions_unless_intentional: true

  - name: "Line starts array sorted"
    after_each_update:
      verify:
        - line_starts_ascending: true
        - line_count_matches: true

# Invariants
invariants:
  - "Comments before edit point never affected by edits after"
  - "Comments after edit point shifted by exact delta"
  - "Position map always consistent with document state"
  - "No position ever negative"
  - "No position ever beyond document length"
  - "Conflicted comments marked explicitly"
  - "All position updates atomic"
  - "Line numbers always positive"
  - "Byte offsets always valid UTF-8 boundaries"

# Recovery
error_recovery:
  - name: "Invalid edit rejected"
    input:
      edit: {position: -1}
    expect:
      error: true
      error_code: "INVALID_EDIT"
      no_state_change: true

  - name: "Position overflow prevented"
    input:
      edit: {position: 999999999, delta: 999999999}
    expect:
      error_or_handled: true
      no_corruption: true

  - name: "Recover from conflict"
    input:
      conflict_detected: true
    expect:
      resolution_applied: true
      or_marked_for_manual_resolution: true
      system_remains_stable: true
